name: CI - Build and Test

# Prevent duplicate runs: 
# - Run on push to main/develop only (not feature branches)
# - Run on pull requests to main/develop (covers feature branch changes)
# - Manual trigger for testing/debugging
# - Scheduled weekly runs for maintenance
# - Use concurrency groups to cancel previous runs
on:
  push:
    branches: [main]
    paths:
      - 'src/**'
      - '.github/workflows/**'
      - 'infra/**'
      - 'package*.json'
      - '*.csproj'
  
  # Manual trigger (includes deployment to dev environment)
  workflow_dispatch:
    inputs:
      debug_mode:
        description: 'Enable debug logging'
        required: false
        default: false
        type: boolean
  
  # Weekly scheduled run (Sundays at 3 AM UTC)
  schedule:
    - cron: '0 3 * * 0'
  pull_request:
    branches: [main]
    paths:
      - 'src/**'
      - '.github/workflows/**'
      - 'infra/**'
      - 'package*.json'
      - '*.csproj'

# Cancel previous runs when pushing new commits
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  bicep-build:
    name: Infrastructure Build
    uses: ./.github/workflows/shared-bicep-build.yml
    secrets: inherit
    permissions:
      contents: read

  frontend-build:
    name: Frontend Build and Test
    uses: ./.github/workflows/shared-frontend-build.yml
    with:
      node-version: ${{ vars.NODE_VERSION || '20' }}
      upload-artifacts: true
      artifact-name: frontend-dist
    secrets: inherit
    permissions:
      contents: read

  backend-build:
    name: Backend Build and Test
    uses: ./.github/workflows/shared-backend-build.yml
    with:
      dotnet-version: ${{ vars.DOTNET_VERSION || '8.0.x' }}
      upload-artifacts: true
      artifact-name: backend-publish
    secrets: inherit
    permissions:
      contents: read

  # ============================================================================
  # ADE END-TO-END VALIDATION JOBS
  # ============================================================================
  # Deploy ADE environments AND application code for complete validation
  # This provides true end-to-end testing of the deployment pipeline
  # - Creates ADE infrastructure environments
  # - Deploys frontend code to Static Web App
  # - Deploys backend code to Function App
  # - Tests deployed applications for functionality
  # - Validates complete deployment pipeline before main branch deployment
  
  deploy-ade-frontend-validation:
    name: ADE Frontend E2E Validation
    runs-on: ubuntu-latest
    needs: [bicep-validation, frontend-build]
    if: ${{ github.event_name != 'scheduled' }}
    outputs:
      ade-environment-name: ${{ steps.create-ade.outputs.ade-environment-name }}
      resource-group-name: ${{ steps.create-ade.outputs.resource-group-name }}
      validation-status: ${{ steps.test-frontend-application.outputs.status }}
    permissions:
      contents: read
      id-token: write
    steps:
    - name: Checkout repository
      uses: actions/checkout@v5
      
    - name: Download infrastructure artifacts
      uses: actions/download-artifact@v6
      with:
        name: infrastructure
        path: ./infra/
      
    - name: Setup Node.js
      uses: actions/setup-node@v6
      with:
        node-version: ${{ vars.NODE_VERSION || '20' }}
        cache: 'npm'
        cache-dependency-path: src/frontend/package-lock.json
      
    - name: Download frontend artifacts
      uses: actions/download-artifact@v6
      with:
        name: frontend-dist
        path: ./src/frontend/dist/
        
    - name: Azure CLI Login
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Create ADE Frontend Environment
      id: create-ade
      run: |
        echo "ðŸš€ Creating ADE frontend environment for validation..."
        
        # Generate unique environment name based on event type (includes run attempt for reruns)
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          ADE_ENV_NAME="pr-fd-${{ github.event.number }}-${{ github.run_number }}-${{ github.run_attempt }}"
        else
          ADE_ENV_NAME="main-fd-${{ github.run_number }}-${{ github.run_attempt }}"
        fi
        
        echo "ADE_ENVIRONMENT_NAME=$ADE_ENV_NAME" >> $GITHUB_ENV
        echo "ade-environment-name=$ADE_ENV_NAME" >> $GITHUB_OUTPUT
        
        # Construct resource group name using ADE naming convention
        RESOURCE_GROUP="ai-foundry-$ADE_ENV_NAME"
        echo "RESOURCE_GROUP_NAME=$RESOURCE_GROUP" >> $GITHUB_ENV
        echo "resource-group-name=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
        
        # Update static ADE parameters file with dynamic environment name
        jq --arg applicationName "$ADE_ENV_NAME" '.applicationName = $applicationName' infra/environments/frontend/ade.parameters.json > /tmp/ade-frontend-params.json
        
        # Calculate expiration time (8 hours from now)
        EXPIRATION_TIME=$(date -u -d "+8 hours" '+%Y-%m-%dT%H:%M:%SZ')
        echo "ðŸ•’ Setting environment expiration to: $EXPIRATION_TIME"
        
        # Create ADE environment with 8-hour expiration
        echo "ðŸ“¦ Deploying ADE frontend environment: $ADE_ENV_NAME (expires in 8 hours)"
        az devcenter dev environment create \
          --dev-center-name "devcenter-eus-dev" \
          --project-name "ai-foundry" \
          --catalog-name "ai-in-abox-infrastructure" \
          --environment-definition-name "AI_Foundry_SPA_Frontend" \
          --environment-type "dev" \
          --name "$ADE_ENV_NAME" \
          --parameters /tmp/ade-frontend-params.json \
          --expiration "$EXPIRATION_TIME" \
          --no-wait
        
        echo "â³ Waiting for ADE frontend environment deployment to complete..."
        
        # Wait for deployment to complete (timeout after 10 minutes)
        timeout=600
        elapsed=0
        while [ $elapsed -lt $timeout ]; do
          status=$(az devcenter dev environment show \
            --dev-center-name "devcenter-eus-dev" \
            --project-name "ai-foundry" \
            --name "$ADE_ENV_NAME" \
            --query "provisioningState" \
            --output tsv || echo "NotFound")
          
          echo "ðŸ” Frontend environment status: $status (${elapsed}s elapsed)"
          
          if [ "$status" = "Succeeded" ]; then
            echo "âœ… ADE frontend environment deployed successfully!"
            break
          elif [ "$status" = "Failed" ]; then
            echo "âŒ ADE frontend environment deployment failed!"
            exit 1
          fi
          
          sleep 30
          elapsed=$((elapsed + 30))
        done
        
        if [ $elapsed -ge $timeout ]; then
          echo "âŒ ADE frontend environment deployment timed out after 10 minutes!"
          exit 1
        fi
    
    - name: Validate Frontend Deployment
      id: validate-deployment
      run: |
        echo "ðŸ” Validating frontend deployment in ADE environment..."
        
        # Get resource group name from previous step output
        RESOURCE_GROUP="${{ steps.create-ade.outputs.resource-group-name }}"
        
        # Find Static Web App by resource type
        STATIC_WEB_APP_NAME=$(az staticwebapp list \
          --resource-group "$RESOURCE_GROUP" \
          --query "[0].name" \
          --output tsv)
        
        if [ -z "$STATIC_WEB_APP_NAME" ] || [ "$STATIC_WEB_APP_NAME" = "null" ]; then
          echo "âŒ No Static Web App found in resource group: $RESOURCE_GROUP"
          exit 1
        fi
        
        echo "âœ… Frontend infrastructure validation passed - Static Web App: $STATIC_WEB_APP_NAME"

    - name: Install SWA CLI
      run: |
        echo "ðŸ“¦ Installing Azure Static Web Apps CLI..."
        npm install -g @azure/static-web-apps-cli

    - name: Deploy Frontend Code to ADE Static Web App
      run: |
        echo "ðŸš€ Deploying frontend code to ADE Static Web App..."
        
        # Get resource group and Static Web App name from previous steps
        RESOURCE_GROUP="${{ steps.create-ade.outputs.resource-group-name }}"
        STATIC_WEB_APP_NAME=$(az staticwebapp list \
          --resource-group "$RESOURCE_GROUP" \
          --query "[0].name" \
          --output tsv)
        
        if [ -z "$STATIC_WEB_APP_NAME" ] || [ "$STATIC_WEB_APP_NAME" = "null" ]; then
          echo "âŒ Static Web App not found for deployment"
          exit 1
        fi
        
        echo "ðŸ“¦ Deploying to Static Web App: $STATIC_WEB_APP_NAME"
        
        # For ADE environments, rebuild frontend with demonstration/testing backend URL
        echo "ðŸ”§ Rebuilding frontend for ADE environment..."
        cd src/frontend
        
        # Set environment variables for ADE build (uses simulation mode for testing)
        export VITE_BACKEND_URL="https://demo-backend.azure.com/api"
        export VITE_USE_BACKEND=false
        export VITE_PUBLIC_MODE=false
        export VITE_AI_FOUNDRY_AGENT_NAME="AI in A Box (ADE Test)"
        
        echo "Building ADE frontend with demonstration settings:"
        echo "  VITE_BACKEND_URL=$VITE_BACKEND_URL"
        echo "  VITE_USE_BACKEND=$VITE_USE_BACKEND"
        echo "  VITE_PUBLIC_MODE=$VITE_PUBLIC_MODE"
        
        # Install dependencies and rebuild
        npm ci
        npm run build:dev
        
        # Go back to root
        cd ../..
        
        # Get deployment token for the Static Web App
        DEPLOYMENT_TOKEN=$(az staticwebapp secrets list \
          --name "$STATIC_WEB_APP_NAME" \
          --resource-group "$RESOURCE_GROUP" \
          --query "properties.apiKey" \
          --output tsv)
        
        if [ -z "$DEPLOYMENT_TOKEN" ] || [ "$DEPLOYMENT_TOKEN" = "null" ]; then
          echo "âŒ Failed to get deployment token for Static Web App"
          exit 1
        fi
        
        # Deploy using SWA CLI
        swa deploy \
          --app-location "./src/frontend/dist" \
          --deployment-token "$DEPLOYMENT_TOKEN" \
          --env "default"
        
        echo "âœ… Frontend code deployed successfully to ADE environment!"

    - name: Test Frontend Application
      id: test-frontend-application
      run: |
        echo "ðŸ§ª Testing deployed frontend application..."
        
        # Get resource group and Static Web App details
        RESOURCE_GROUP="${{ steps.create-ade.outputs.resource-group-name }}"
        STATIC_WEB_APP_NAME=$(az staticwebapp list \
          --resource-group "$RESOURCE_GROUP" \
          --query "[0].name" \
          --output tsv)
        
        # Get Static Web App URL
        STATIC_WEB_APP_HOSTNAME=$(az staticwebapp show \
          --name "$STATIC_WEB_APP_NAME" \
          --resource-group "$RESOURCE_GROUP" \
          --query "defaultHostname" \
          --output tsv)
        
        if [ -z "$STATIC_WEB_APP_HOSTNAME" ] || [ "$STATIC_WEB_APP_HOSTNAME" = "null" ]; then
          echo "âŒ Failed to get Static Web App hostname"
          exit 1
        fi
        
        STATIC_WEB_APP_URL="https://$STATIC_WEB_APP_HOSTNAME"
        echo "ðŸ”— Testing application at: $STATIC_WEB_APP_URL"
        
        # Wait for deployment to propagate
        sleep 30
        
        # Test that the application loads
        echo "ðŸ¥ Testing application accessibility..."
        max_attempts=10
        attempt=1
        app_accessible=false
        
        while [ $attempt -le $max_attempts ]; do
          echo "ðŸ” Accessibility test attempt $attempt/$max_attempts..."
          
          if curl -f -s "$STATIC_WEB_APP_URL" -o /dev/null; then
            echo "âœ… Frontend application is accessible!"
            app_accessible=true
            break
          else
            echo "â³ Application not ready yet (attempt $attempt/$max_attempts)..."
            if [ $attempt -lt $max_attempts ]; then
              sleep 30
            fi
          fi
          
          attempt=$((attempt + 1))
        done
        
        if [ "$app_accessible" = false ]; then
          echo "âŒ Frontend application failed accessibility test after $max_attempts attempts"
          exit 1
        fi
        
        echo "âœ… Frontend application deployment and testing completed successfully!"
        
        # Set final validation status
        echo "status=success" >> $GITHUB_OUTPUT

  deploy-ade-backend-validation:
    name: ADE Backend Environment
    runs-on: ubuntu-latest
    needs: [bicep-build, backend-build]
    if: ${{ github.event_name != 'scheduled' }}
    permissions:
      contents: read
      id-token: write
    outputs:
      ade-environment-name: ${{ steps.create-ade.outputs.ade-environment-name }}
      resource-group-name: ${{ steps.create-ade.outputs.resource-group-name }}
      function-app-name: ${{ steps.validate-infrastructure.outputs.function-app-name }}
      function-app-url: ${{ steps.validate-infrastructure.outputs.function-app-url }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v5
      
    - name: Download infrastructure artifacts
      uses: actions/download-artifact@v6
      with:
        name: infrastructure
        path: ./infra/     
        
    - name: Azure CLI Login
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Create ADE Backend Environment
      id: create-ade
      run: |
        echo "ðŸš€ Creating ADE backend environment for validation..."
        
        # Generate unique environment name based on event type (includes run attempt for reruns)
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          ADE_ENV_NAME="pr-be-${{ github.event.number }}-${{ github.run_number }}-${{ github.run_attempt }}"
        else
          ADE_ENV_NAME="main-be-${{ github.run_number }}-${{ github.run_attempt }}"
        fi
        
        echo "ADE_ENVIRONMENT_NAME=$ADE_ENV_NAME" >> $GITHUB_ENV
        echo "ade-environment-name=$ADE_ENV_NAME" >> $GITHUB_OUTPUT
        
        # Construct resource group name using ADE naming convention
        RESOURCE_GROUP="ai-foundry-$ADE_ENV_NAME"
        echo "RESOURCE_GROUP_NAME=$RESOURCE_GROUP" >> $GITHUB_ENV
        echo "resource-group-name=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
        
        # Update static ADE parameters file with dynamic environment name
        jq --arg applicationName "$ADE_ENV_NAME" '.applicationName = $applicationName' infra/environments/backend/ade.parameters.json > /tmp/ade-backend-params.json
        
        # Calculate expiration time (8 hours from now)
        EXPIRATION_TIME=$(date -u -d "+8 hours" '+%Y-%m-%dT%H:%M:%SZ')
        echo "ðŸ•’ Setting environment expiration to: $EXPIRATION_TIME"
        
        # Create ADE environment with 8-hour expiration
        echo "ðŸ“¦ Deploying ADE backend environment: $ADE_ENV_NAME (expires in 8 hours)"
        az devcenter dev environment create \
          --dev-center-name "devcenter-eus-dev" \
          --project-name "ai-foundry" \
          --catalog-name "ai-in-abox-infrastructure" \
          --environment-definition-name "AI_Foundry_SPA_Backend" \
          --environment-type "dev" \
          --name "$ADE_ENV_NAME" \
          --parameters /tmp/ade-backend-params.json \
          --expiration "$EXPIRATION_TIME" \
          --no-wait
        
        echo "â³ Waiting for ADE backend environment deployment to complete..."
        
        # Wait for deployment to complete (timeout after 15 minutes for backend)
        timeout=900
        elapsed=0
        while [ $elapsed -lt $timeout ]; do
          status=$(az devcenter dev environment show \
            --dev-center-name "devcenter-eus-dev" \
            --project-name "ai-foundry" \
            --name "$ADE_ENV_NAME" \
            --query "provisioningState" \
            --output tsv || echo "NotFound")
          
          echo "ðŸ” Backend environment status: $status (${elapsed}s elapsed)"
          
          if [ "$status" = "Succeeded" ]; then
            echo "âœ… ADE backend environment deployed successfully!"
            break
          elif [ "$status" = "Failed" ]; then
            echo "âŒ ADE backend environment deployment failed!"
            exit 1
          fi
          
          sleep 30
          elapsed=$((elapsed + 30))
        done
        
        if [ $elapsed -ge $timeout ]; then
          echo "âŒ ADE backend environment deployment timed out after 15 minutes!"
          exit 1
        fi
    
    - name: Validate Backend Infrastructure
      id: validate-infrastructure
      run: |
        echo "ðŸ” Validating backend infrastructure in ADE environment..."
        
        # Get resource group name from previous step output
        RESOURCE_GROUP="${{ steps.create-ade.outputs.resource-group-name }}"
        
        # Find Function App by resource type (infrastructure validation only)
        FUNCTION_APP_NAME=$(az functionapp list \
          --resource-group "$RESOURCE_GROUP" \
          --query "[0].name" \
          --output tsv)
        
        if [ -z "$FUNCTION_APP_NAME" ] || [ "$FUNCTION_APP_NAME" = "null" ]; then
          echo "âŒ No Function App found in resource group: $RESOURCE_GROUP"
          exit 1
        fi
        
        echo "âœ… Backend infrastructure validation passed - Function App created: $FUNCTION_APP_NAME"

        ADE_ENV_NAME="${{ steps.create-ade.outputs.ade-environment-name }}"
        FUNCTION_APP_URL="https://func-${ADE_ENV_NAME}-bk-dev-eus2.azurewebsites.net"
        echo "function-app-name=$FUNCTION_APP_NAME" >> $GITHUB_OUTPUT
        echo "function-app-url=$FUNCTION_APP_URL" >> $GITHUB_OUTPUT

  deploy-ade-backend-code:
    name: ADE Backend Code Deployment
    needs: [deploy-ade-backend-validation]
    uses: ./.github/workflows/shared-backend-deploy.yml
    permissions: 
      contents: read
      id-token: write
    with:
      artifact-name: backend-publish
      artifact-download-path: backend-artifacts
      function-app-name: ${{ needs.deploy-ade-backend-validation.outputs.function-app-name }}
      resource-group-name: ${{ needs.deploy-ade-backend-validation.outputs.resource-group-name }}
      function-app-url: ${{ needs.deploy-ade-backend-validation.outputs.function-app-url }}
      environment-name: ${{ needs.deploy-ade-backend-validation.outputs.ade-environment-name }}
      environment: ade
      run-tests: true
    secrets: inherit

  ade-validation-summary:
    name: ADE E2E Validation Summary
    runs-on: ubuntu-latest
    needs: [deploy-ade-frontend-validation, deploy-ade-backend-validation, deploy-ade-backend-code]
    outputs:
      validation-status: ${{ steps.summary.outputs.status }}
    permissions:
      contents: read
    
    steps:
    - name: Validation Summary
      id: summary
      run: |
        echo "ðŸ“‹ ADE End-to-End Validation Summary"
        echo "===================================="

        FRONTEND_STATUS="${{ needs.deploy-ade-frontend-validation.outputs.validation-status }}"
        BACKEND_STATUS="${{ needs.deploy-ade-backend-code.outputs.test-status }}"

        echo "Frontend Deployment & Testing: $FRONTEND_STATUS"
        echo "Backend Deployment & Testing: $BACKEND_STATUS"

        if [ "$FRONTEND_STATUS" = "success" ] && [ "$BACKEND_STATUS" = "success" ]; then
          echo "âœ… All ADE end-to-end validations passed!"
          echo "   - Infrastructure deployed successfully"
          echo "   - Application code deployed successfully"
          echo "   - Applications tested and functional"
          echo "status=success" >> $GITHUB_OUTPUT
        else
          echo "âŒ ADE end-to-end validation failed!"
          echo "status=failed" >> $GITHUB_OUTPUT
          exit 1
        fi
    
    - name: ADE Environment Information
      run: |
        echo "## ðŸ—ï¸ ADE End-to-End Validation Environments" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“‹ Environment Details" >> $GITHUB_STEP_SUMMARY
        echo "- **Frontend Environment**: \`${{ needs.deploy-ade-frontend-validation.outputs.ade-environment-name }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Backend Environment**: \`${{ needs.deploy-ade-backend-validation.outputs.ade-environment-name }}\`" >> $GITHUB_STEP_SUMMARY
        if [ -n "${{ needs.deploy-ade-backend-code.outputs.function-app-url }}" ]; then
          echo "- **Backend Function App URL**: [${{ needs.deploy-ade-backend-code.outputs.function-app-url }}](${{ needs.deploy-ade-backend-code.outputs.function-app-url }})" >> $GITHUB_STEP_SUMMARY
        fi
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### âœ… Validation Completed" >> $GITHUB_STEP_SUMMARY
        echo "- **Infrastructure Deployment**: ADE environments created successfully" >> $GITHUB_STEP_SUMMARY
        echo "- **Frontend Code Deployment**: Static Web App deployed and tested" >> $GITHUB_STEP_SUMMARY
        echo "- **Backend Code Deployment**: Function App deployed and tested" >> $GITHUB_STEP_SUMMARY
        echo "- **Application Testing**: End-to-end functionality verified" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ•’ Automatic Cleanup" >> $GITHUB_STEP_SUMMARY
        echo "âœ… **Note**: ADE environments are configured with 8-hour expiration and will be automatically deleted." >> $GITHUB_STEP_SUMMARY
        echo "No manual cleanup required." >> $GITHUB_STEP_SUMMARY

  deploy-dev-infrastructure:
    name: Deploy Dev Infrastructure
    uses: ./.github/workflows/shared-infrastructure-deploy.yml
    needs: [bicep-build, ade-validation-summary]
    # For scheduled runs: skip ADE validation and proceed directly to deployment
    # For push/manual: require successful ADE validation or skip condition
    permissions:
      contents: read
      id-token: write
    if: |
      
        ( github.event_name != 'scheduled' &&
        needs.ade-validation-summary.outputs.validation-status == 'success' )
        &&
        github.ref == 'refs/heads/main'
      
    with:
      environment: 'dev'
      bicep-template: 'infra/main-orchestrator.bicep'
      parameters-file: 'infra/dev-orchestrator.parameters.bicepparam'
      location: 'eastus2'
      validate-only: false
      artifact-name: 'infrastructure'
    secrets: inherit

  deploy-agent:
    name: Deploy AI Foundry Agent
    runs-on: ubuntu-latest
    needs: [deploy-dev-infrastructure]
    permissions:
      contents: read
    outputs:
      agent-id: ${{ steps.deploy-agent.outputs.agent-id }}
      agent-name: ${{ steps.deploy-agent.outputs.agent-name }}
    environment:
      name: dev
    steps:
    - name: Checkout repository
      uses: actions/checkout@v5
      
    - name: Azure CLI Login
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: Validate AI Foundry Infrastructure
      run: |
        echo "ðŸ” Validating AI Foundry infrastructure outputs..."
        
        AI_FOUNDRY_ENDPOINT="${{ needs.deploy-dev-infrastructure.outputs.ai-foundry-endpoint }}"
        
        if [ "$AI_FOUNDRY_ENDPOINT" = "not-found" ] || [ -z "$AI_FOUNDRY_ENDPOINT" ]; then
          echo "âŒ AI Foundry endpoint not found in infrastructure outputs"
          exit 1
        fi
        
        echo "âœ… AI Foundry infrastructure validated:"
        echo "  - Endpoint: $AI_FOUNDRY_ENDPOINT"
        
    - name: Deploy AI Foundry Agent
      id: deploy-agent
      shell: pwsh
      run: |
        Write-Host "ðŸ¤– Deploying AI Foundry agent..."
        
        # Execute the agent deployment script with proper parameters
        $output = & "${{ github.workspace }}/deploy-scripts/deploy-agent.ps1" -AiFoundryEndpoint "${{ needs.deploy-dev-infrastructure.outputs.ai-foundry-endpoint }}" -AgentName "AI in A Box" -OutputFormat "json" 2>&1
        
        # Capture the script output
        Write-Host "Script output:"
        Write-Host $output
        
        # Look for the AGENT_DEPLOYMENT_RESULT line in the output
        $resultLine = $output | Where-Object { $_ -match "AGENT_DEPLOYMENT_RESULT:" }
        
        if ($resultLine) {
          $jsonPart = $resultLine -replace ".*AGENT_DEPLOYMENT_RESULT:\s*", ""
          Write-Host "Found result: $jsonPart"
          
          # Parse the JSON result
          $result = $jsonPart | ConvertFrom-Json
          
          if ($result.success) {
            Write-Host "âœ… Agent deployment successful!"
            Write-Host "Agent ID: $($result.agentId)"
            Write-Host "Agent Name: $($result.agentName)"
            
            # Set outputs for next job
            echo "agent-id=$($result.agentId)" >> $env:GITHUB_OUTPUT
            echo "agent-name=$($result.agentName)" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "âŒ Agent deployment failed: $($result.error)"
            exit 1
          }
        } else {
          Write-Host "âŒ Could not find agent deployment result in output"
          exit 1
        }
        
    - name: Agent Deployment Summary
      run: |
        echo "## ðŸ¤– AI Foundry Agent Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### âœ… Agent Deployment Successful" >> $GITHUB_STEP_SUMMARY
        echo "- **Agent Name**: \`${{ steps.deploy-agent.outputs.agent-name }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Agent ID**: \`${{ steps.deploy-agent.outputs.agent-id }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **AI Foundry Endpoint**: \`${{ needs.deploy-dev-infrastructure.outputs.ai-foundry-endpoint }}\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ”§ Deployment Details" >> $GITHUB_STEP_SUMMARY
        echo "- **Deployment Method**: PowerShell Script via GitHub Actions" >> $GITHUB_STEP_SUMMARY
        echo "- **Configuration Source**: YAML file (src/agent/ai_in_a_box.yaml)" >> $GITHUB_STEP_SUMMARY
        echo "- **Authentication**: Azure CLI with Service Principal" >> $GITHUB_STEP_SUMMARY

  deploy-backend-code:
    name: Deploy Backend Code
    needs: [backend-build, deploy-dev-infrastructure, deploy-agent]
    permissions:
      contents: read
      id-token: write
    uses: ./.github/workflows/shared-backend-deploy.yml
    with:
      artifact-name: backend-publish
      artifact-download-path: backend-artifacts
      function-app-name: ${{ needs.deploy-dev-infrastructure.outputs.backend-function-app-name }}
      resource-group-name: ${{ needs.deploy-dev-infrastructure.outputs.backend-resource-group-name }}
      function-app-url: ${{ needs.deploy-dev-infrastructure.outputs.backend-function-app-url }}
      environment-name: 'Dev'
      run-tests: true
      agent-id: ${{ needs.deploy-agent.outputs.agent-id }}
      agent-name: ${{ needs.deploy-agent.outputs.agent-name }}
      update-agent-settings: true
      environment: 'dev'
    secrets: inherit

  deploy-frontend-code:
    name: Deploy Frontend Code
    runs-on: ubuntu-latest
    needs: [frontend-build, deploy-dev-infrastructure]
    environment:
      name: dev
    permissions:
      contents: read
      id-token: write
    steps:
    - name: Checkout repository
      uses: actions/checkout@v5
      
    - name: Setup Node.js
      uses: actions/setup-node@v6
      with:
        node-version: ${{ vars.NODE_VERSION || '20' }}
        cache: 'npm'
        cache-dependency-path: src/frontend/package-lock.json
        
    - name: Download frontend artifacts
      uses: actions/download-artifact@v6
      with:
        name: frontend-dist
        path: ./src/frontend/dist/
        
    - name: Azure CLI Login
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: Validate Infrastructure Outputs
      run: |
        echo "ðŸ” Validating infrastructure deployment outputs..."
        
        STATIC_WEB_APP_NAME="${{ needs.deploy-dev-infrastructure.outputs.frontend-static-web-app-name }}"
        RESOURCE_GROUP_NAME="${{ needs.deploy-dev-infrastructure.outputs.frontend-resource-group-name }}"
        BACKEND_URL="${{ needs.deploy-dev-infrastructure.outputs.backend-function-app-url }}"
        
        if [ "$STATIC_WEB_APP_NAME" = "not-found" ] || [ -z "$STATIC_WEB_APP_NAME" ]; then
          echo "âŒ Frontend Static Web App name not found in infrastructure outputs"
          exit 1
        fi
        
        if [ "$RESOURCE_GROUP_NAME" = "not-found" ] || [ -z "$RESOURCE_GROUP_NAME" ]; then
          echo "âŒ Frontend Resource Group name not found in infrastructure outputs"
          exit 1
        fi
        
        echo "âœ… Infrastructure outputs validated:"
        echo "  - Static Web App: $STATIC_WEB_APP_NAME"
        echo "  - Resource Group: $RESOURCE_GROUP_NAME"
        echo "  - Backend URL: $BACKEND_URL"
        
    - name: Install SWA CLI
      run: |
        echo "ðŸ“¦ Installing Azure Static Web Apps CLI..."
        npm install -g @azure/static-web-apps-cli

    - name: Deploy Frontend Code to Static Web App
      run: |
        echo "ðŸš€ Deploying frontend code to Static Web App..."
        
        # Get infrastructure outputs
        STATIC_WEB_APP_NAME="${{ needs.deploy-dev-infrastructure.outputs.frontend-static-web-app-name }}"
        RESOURCE_GROUP_NAME="${{ needs.deploy-dev-infrastructure.outputs.frontend-resource-group-name }}"
        BACKEND_URL="${{ needs.deploy-dev-infrastructure.outputs.backend-function-app-url }}/api"
        
        echo "ðŸ“¦ Deploying to Static Web App: $STATIC_WEB_APP_NAME"
        echo "ðŸ”— Backend API URL: $BACKEND_URL"
        
        # Install dependencies and rebuild with correct backend URL
        echo "ðŸ”§ Rebuilding frontend with correct backend URL..."
        cd src/frontend
        
        # Set environment variables for the build
        export VITE_BACKEND_URL="$BACKEND_URL"
        export VITE_USE_BACKEND=true
        export VITE_PUBLIC_MODE=true
        export VITE_AI_FOUNDRY_AGENT_NAME="AI in A Box"
        
        echo "Building with:"
        echo "  VITE_BACKEND_URL=$VITE_BACKEND_URL"
        echo "  VITE_USE_BACKEND=$VITE_USE_BACKEND"
        echo "  VITE_PUBLIC_MODE=$VITE_PUBLIC_MODE"
        
        # Install dependencies (use cache if available)
        npm ci
        
        # Build the frontend with the correct backend URL
        npm run build:dev
        
        # Go back to root
        cd ../..
        
        # Get deployment token for the Static Web App
        DEPLOYMENT_TOKEN=$(az staticwebapp secrets list \
          --name "$STATIC_WEB_APP_NAME" \
          --resource-group "$RESOURCE_GROUP_NAME" \
          --query "properties.apiKey" \
          --output tsv)
        
        if [ -z "$DEPLOYMENT_TOKEN" ] || [ "$DEPLOYMENT_TOKEN" = "null" ]; then
          echo "âŒ Failed to get deployment token for Static Web App"
          exit 1
        fi
        
        # Deploy using SWA CLI
        swa deploy \
          --app-location "./src/frontend/dist" \
          --deployment-token "$DEPLOYMENT_TOKEN" \
          --env "default"
        
        echo "âœ… Frontend code deployed successfully!"
        
    - name: Frontend Deployment Summary
      run: |
        echo "## ðŸŒ Frontend Code Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### âœ… Deployment Successful" >> $GITHUB_STEP_SUMMARY
        echo "- **Static Web App**: \`${{ needs.deploy-dev-infrastructure.outputs.frontend-static-web-app-name }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Resource Group**: \`${{ needs.deploy-dev-infrastructure.outputs.frontend-resource-group-name }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Application URL**: [${{ needs.deploy-dev-infrastructure.outputs.frontend-static-web-app-url }}](${{ needs.deploy-dev-infrastructure.outputs.frontend-static-web-app-url }})" >> $GITHUB_STEP_SUMMARY
        echo "- **Backend Integration**: ${{ needs.deploy-dev-infrastructure.outputs.backend-function-app-url }}/api" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ”§ Deployment Details" >> $GITHUB_STEP_SUMMARY
        echo "- **Action Used**: Azure CLI + SWA CLI (Native Azure Commands)" >> $GITHUB_STEP_SUMMARY
        echo "- **Build Artifacts**: Frontend rebuilt during deployment with correct backend URL" >> $GITHUB_STEP_SUMMARY
        echo "- **Deploy Method**: Native GitHub Actions with Azure CLI" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment Variables**: VITE_BACKEND_URL set from infrastructure outputs at build time" >> $GITHUB_STEP_SUMMARY
  build-summary:
    name: Build Summary
    runs-on: ubuntu-latest
    needs: [bicep-build, frontend-build, backend-build, deploy-dev-infrastructure, deploy-backend-code, deploy-frontend-code]
    if: always()
    permissions:
      contents: read

    steps:
       
    - name: Display build summary
      run: |
        echo "## ðŸ—ï¸ Build Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Bicep validation summary
        if [ "${{ needs.bicep-validation.result }}" = "success" ]; then
          echo "### âœ… Bicep Infrastructure Validation Successful" >> $GITHUB_STEP_SUMMARY
        else
          echo "### âŒ Bicep Infrastructure Build Failed" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ needs.bicep-build.result }}" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Frontend summary
        if [ "${{ needs.frontend-build.result }}" = "success" ]; then
          echo "### âœ… Frontend Build Successful" >> $GITHUB_STEP_SUMMARY
        else
          echo "### âŒ Frontend Build Failed" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Backend summary
        if [ "${{ needs.backend-build.result }}" = "success" ]; then
          echo "### âœ… Backend Build Successful" >> $GITHUB_STEP_SUMMARY
        else
          echo "### âŒ Backend Build Failed" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Infrastructure deployment summary (shows on main branch pushes, manual triggers, and scheduled runs)
        if [ "${{ github.ref }}" = "refs/heads/main" ] && "${{ github.event_name }}" != "pull_request"; then
          if [ "${{ needs.deploy-dev-infrastructure.result }}" = "success" ]; then
            echo "### âœ… Dev Infrastructure Deployment Successful" >> $GITHUB_STEP_SUMMARY
            echo "- **Status**: Infrastructure deployed via Azure CLI + Bicep" >> $GITHUB_STEP_SUMMARY
            echo "- **Environment**: dev (eastus2)" >> $GITHUB_STEP_SUMMARY
            echo "- **Template**: main-orchestrator.bicep" >> $GITHUB_STEP_SUMMARY
            echo "- **Parameters**: dev-orchestrator.parameters.bicepparam" >> $GITHUB_STEP_SUMMARY
            echo "- **Scope**: Subscription-level deployment to multiple resource groups" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.deploy-dev-infrastructure.result }}" = "failure" ]; then
            echo "### âŒ Dev Infrastructure Deployment Failed" >> $GITHUB_STEP_SUMMARY
            echo "- **Status**: ${{ needs.deploy-dev-infrastructure.result }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Note**: Check job logs for detailed error information" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.deploy-dev-infrastructure.result }}" = "skipped" ]; then
            echo "### â­ï¸ Dev Infrastructure Deployment Skipped" >> $GITHUB_STEP_SUMMARY
            echo "- **Reason**: Infrastructure deployment runs on main branch pushes, manual triggers, and scheduled runs" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Backend code deployment summary
          if [ "${{ needs.deploy-backend-code.result }}" = "success" ]; then
            echo "### âœ… Backend Code Deployment Successful" >> $GITHUB_STEP_SUMMARY
            echo "- **Status**: Backend Function App code deployed in parallel with frontend" >> $GITHUB_STEP_SUMMARY
            echo "- **Method**: Azure/functions-action@v1 (Native GitHub Action)" >> $GITHUB_STEP_SUMMARY
            echo "- **Dependency**: Triggered after successful infrastructure deployment" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.deploy-backend-code.result }}" = "failure" ]; then
            echo "### âŒ Backend Code Deployment Failed" >> $GITHUB_STEP_SUMMARY
            echo "- **Status**: ${{ needs.deploy-backend-code.result }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Note**: Check job logs for detailed error information" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.deploy-backend-code.result }}" = "skipped" ]; then
            echo "### â­ï¸ Backend Code Deployment Skipped" >> $GITHUB_STEP_SUMMARY
            echo "- **Reason**: Skipped due to infrastructure deployment failure or not on main branch" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Frontend code deployment summary  
          if [ "${{ needs.deploy-frontend-code.result }}" = "success" ]; then
            echo "### âœ… Frontend Code Deployment Successful" >> $GITHUB_STEP_SUMMARY
            echo "- **Status**: Frontend Static Web App code deployed in parallel with backend" >> $GITHUB_STEP_SUMMARY
            echo "- **Method**: Azure CLI + SWA CLI (Native Azure Commands)" >> $GITHUB_STEP_SUMMARY
            echo "- **Dependency**: Triggered after successful infrastructure deployment" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.deploy-frontend-code.result }}" = "failure" ]; then
            echo "### âŒ Frontend Code Deployment Failed" >> $GITHUB_STEP_SUMMARY
            echo "- **Status**: ${{ needs.deploy-frontend-code.result }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Note**: Check job logs for detailed error information" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.deploy-frontend-code.result }}" = "skipped" ]; then
            echo "### â­ï¸ Frontend Code Deployment Skipped" >> $GITHUB_STEP_SUMMARY
            echo "- **Reason**: Skipped due to infrastructure deployment failure or not on main branch" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "### ðŸ“‹ Next Steps" >> $GITHUB_STEP_SUMMARY
        echo "- Review build artifacts if needed" >> $GITHUB_STEP_SUMMARY
        echo "- Run local tests: \`npm test\` (frontend) and \`dotnet test\` (backend)" >> $GITHUB_STEP_SUMMARY
        if [ "${{ github.event_name }}" = "push" ] && [ "${{ github.ref }}" = "refs/heads/main" ] || [ "${{ github.event_name }}" = "workflow_dispatch" ] || [ "${{ github.event_name }}" = "schedule" ]; then
          echo "- **Automated Deployment**: Infrastructure and application code deployed automatically using native GitHub Actions (Backend and Frontend in parallel)" >> $GITHUB_STEP_SUMMARY
          echo "- **Local Development**: Use deployment scripts in \`deploy-scripts/\` for local testing only" >> $GITHUB_STEP_SUMMARY
        else
          echo "- **Local Development**: Use deployment scripts in \`deploy-scripts/\` for local testing only" >> $GITHUB_STEP_SUMMARY
          echo "- **Note**: Automated deployment using native GitHub Actions runs on main branch pushes, manual triggers, and scheduled runs (Backend and Frontend in parallel)" >> $GITHUB_STEP_SUMMARY
        fi
        

  # Create GitHub issue when workflow fails (scheduled runs or manual triggers)
  create-failure-issue:
    name: 'Create Failure Issue'
    runs-on: ubuntu-latest
    if: ${{ (github.event_name == 'schedule') && (needs.frontend-build.result == 'failure' || needs.backend-build.result == 'failure' || needs.deploy-dev-infrastructure.result == 'failure' || needs.deploy-agent.result == 'failure' || needs.deploy-backend-code.result == 'failure' || needs.deploy-frontend-code.result == 'failure' || needs.build-summary.result == 'failure') }}
    needs: [frontend-build, backend-build, deploy-dev-infrastructure, deploy-agent, deploy-backend-code, deploy-frontend-code, build-summary]
    
    permissions:
      issues: write
      contents: read
    
    steps:
      - name: Get your GitHub username
        id: get-username
        run: |
          # Try to get the username from the repository owner
          REPO_OWNER="${{ github.repository_owner }}"
          echo "username=${REPO_OWNER}" >> $GITHUB_OUTPUT
      
      - name: Determine failure details
        id: failure-details
        run: |
          FAILED_JOBS=""
          
          if [ "${{ needs.frontend-build.result }}" = "failure" ]; then
            FAILED_JOBS="${FAILED_JOBS}- Frontend Build\n"
          fi
          if [ "${{ needs.backend-build.result }}" = "failure" ]; then
            FAILED_JOBS="${FAILED_JOBS}- Backend Build\n"
          fi
          if [ "${{ needs.deploy-dev-infrastructure.result }}" = "failure" ]; then
            FAILED_JOBS="${FAILED_JOBS}- Infrastructure Deployment\n"
          fi
          if [ "${{ needs.deploy-agent.result }}" = "failure" ]; then
            FAILED_JOBS="${FAILED_JOBS}- Agent Deployment\n"
          fi
          if [ "${{ needs.deploy-backend-code.result }}" = "failure" ]; then
            FAILED_JOBS="${FAILED_JOBS}- Backend Code Deployment\n"
          fi
          if [ "${{ needs.deploy-frontend-code.result }}" = "failure" ]; then
            FAILED_JOBS="${FAILED_JOBS}- Frontend Code Deployment\n"
          fi
          if [ "${{ needs.build-summary.result }}" = "failure" ]; then
            FAILED_JOBS="${FAILED_JOBS}- Build Summary\n"
          fi
          
          echo "failed_jobs=${FAILED_JOBS}" >> $GITHUB_OUTPUT
          
          # Determine trigger type
          if [ "${{ github.event_name }}" = "schedule" ]; then
            echo "trigger_type=Scheduled Weekly" >> $GITHUB_OUTPUT
          else
            echo "trigger_type=Manual" >> $GITHUB_OUTPUT
          fi
      
      - name: Create GitHub Issue
        uses: actions/github-script@v8
        with:
          script: |
            const title = `ðŸš¨ CI Workflow Failure - ${{ steps.failure-details.outputs.trigger_type }} Run`;
            const body = `## CI Workflow Failed
            
            **Trigger:** ${{ steps.failure-details.outputs.trigger_type }} run
            **Workflow:** ${{ github.workflow }}
            **Run ID:** ${{ github.run_id }}
            **Commit:** ${{ github.sha }}
            **Branch:** ${{ github.ref_name }}
            **Triggered by:** ${{ github.actor }}
            **Date:** ${new Date().toISOString()}
            
            ### Failed Jobs:
            ${{ steps.failure-details.outputs.failed_jobs }}
            
            ### Details:
            - **Workflow Run:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            - **Repository:** ${{ github.repository }}
            - **Environment:** dev
            
            ### Next Steps:
            1. Review the failed job logs in the workflow run
            2. Check for infrastructure or configuration issues
            3. Verify Azure resources and permissions
            4. Test the deployment manually if needed
            5. Close this issue once resolved
            
            ### Debug Information:
            - Frontend Build: ${{ needs.frontend-build.result }}
            - Backend Build: ${{ needs.backend-build.result }}
            - Infrastructure Deployment: ${{ needs.deploy-dev-infrastructure.result }}
            - Agent Deployment: ${{ needs.deploy-agent.result }}
            - Backend Code Deployment: ${{ needs.deploy-backend-code.result }}
            - Frontend Code Deployment: ${{ needs.deploy-frontend-code.result }}
            - Build Summary: ${{ needs.build-summary.result }}
            
            ---
            *This issue was automatically created by the CI workflow failure detection.*`;
            
            // Create the issue
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['bug', 'ci-failure', 'automated'],
              assignees: ['${{ steps.get-username.outputs.username }}']
            });
            
            console.log(`Created issue #${issue.data.number}: ${issue.data.html_url}`);